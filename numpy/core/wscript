import os
import sys
import shutil

from os.path \
    import \
        join as pjoin

import waflib
import waflib.Errors
from waflib.Task \
    import \
        Task

from numpy.distutils.conv_template \
    import \
        process_str as process_c_str
from code_generators.numpy_api \
    import \
        multiarray_api, ufunc_api
from code_generators import generate_numpy_api, generate_ufunc_api, \
        generate_umath

from setup_common \
    import \
        OPTIONAL_STDFUNCS_MAYBE, OPTIONAL_STDFUNCS, C99_FUNCS_EXTENDED, \
        C99_FUNCS_SINGLE, C99_COMPLEX_TYPES, C99_COMPLEX_FUNCS, \
        MANDATORY_FUNCS
import conflib

NUMPYCONFIG_SYM = []

def is_npy_no_signal():
    """Return True if the NPY_NO_SIGNAL symbol must be defined in configuration
    header."""
    return sys.platform == 'win32'

def define_no_smp():
    """Returns True if we should define NPY_NOSMP, False otherwise."""
    #--------------------------------
    # Checking SMP and thread options
    #--------------------------------
    # Python 2.3 causes a segfault when
    #  trying to re-acquire the thread-state
    #  which is done in error-handling
    #  ufunc code.  NPY_ALLOW_C_API and friends
    #  cause the segfault. So, we disable threading
    #  for now.
    if sys.version[:5] < '2.4.2':
        nosmp = 1
    else:
        # Perhaps a fancier check is in order here.
        #  so that threads are only enabled if there
        #  are actually multiple CPUS? -- but
        #  threaded code can be nice even on a single
        #  CPU so that long-calculating code doesn't
        #  block.
        try:
            nosmp = os.environ['NPY_NOSMP']
            nosmp = 1
        except KeyError:
            nosmp = 0
    return nosmp == 1

def config_header_hack():
    if not os.path.exists("build/numpy/core"):
        os.makedirs("build/numpy/core")
    shutil.copy("../config.h", "build/numpy/core")
    if not os.path.exists("build/numpy/core/include/numpy"):
        os.makedirs("build/numpy/core/include/numpy")
    shutil.copy("../_numpyconfig.h", "build/numpy/core/include/numpy")

def type_checks(conf):
    header_name = "Python.h"
    features = "c pyext"
    for c_type in ("int", "long", "short"):
        macro_name = "SIZEOF_%s" % conflib.sanitize_string(c_type)
        conf.check_declaration(macro_name, header_name=header_name,
                               features=features)
        NUMPYCONFIG_SYM.append((macro_name, macro_name))
        #    size = conf.check_type_size(c_type, header_name=header_name,
        #                                features=features)
        #    NUMPYCONFIG_SYM.append((macro_name, str(size)))
        #else:
        #    NUMPYCONFIG_SYM.append((macro_name, macro_name))

    for c_type, e_size in (("float", 4), ("double", 8), ("long double", 12)):
        macro_name = "SIZEOF_%s" % conflib.sanitize_string(c_type)
        size = conf.check_type_size(c_type, header_name=header_name,
                                    features=features, expected_size=e_size)
        NUMPYCONFIG_SYM.append((macro_name, str(size)))

        macro_name = "SIZEOF_COMPLEX_%s" % conflib.sanitize_string(c_type)
        complex_def = "struct {%s __x; %s __y;}" % (c_type, c_type)
        size = conf.check_type_size(complex_def, header_name=header_name,
                                    features=features, expected_size=2*e_size)
        NUMPYCONFIG_SYM.append((macro_name, str(size)))

    if sys.platform != 'darwin':
        conf.check_ldouble_representation()

    conf.check_type("Py_intptr_t", header_name=header_name, features=features)

    # We check declaration AND type because that's how distutils does it.
    try:
        conf.check_declaration("PY_LONG_LONG", header_name=header_name,
                               features=features)
    except waflib.Errors.ConfigurationError:
        size = conf.check_type_size("PY_LONG_LONG", header_name=header_name,
                                    features=features)
        NUMPYCONFIG_SYM.append(("DEFINE_NPY_SIZEOF_LONGLONG",
                                "#define NPY_SIZEOF_LONGLONG %d" % size))
        NUMPYCONFIG_SYM.append(("DEFINE_NPY_SIZEOF_PY_LONG_LONG",
                                "#define NPY_SIZEOF_PY_LONG_LONG %d" % size))
    else:
        NUMPYCONFIG_SYM.append(("DEFINE_NPY_SIZEOF_LONGLONG", ""))
        NUMPYCONFIG_SYM.append(("DEFINE_NPY_SIZEOF_PY_LONG_LONG", ""))

    conf.check_declaration("CHAR_BIT", header_name=header_name, features=features)

def signal_smp_checks(conf):
    if is_npy_no_signal():
        NUMPYCONFIG_SYM.append(("DEFINE_NPY_NO_SIGNAL", "#define NPY_NO_SIGNAL\n"))
        conf.define("__NPY_PRIVATE_NO_SIGNAL", 1)
    else:
        NUMPYCONFIG_SYM.append(("DEFINE_NPY_NO_SIGNAL", ""))

    if define_no_smp():
        NUMPYCONFIG_SYM.append(("NPY_NO_SMP", 1))
    else:
        NUMPYCONFIG_SYM.append(("NPY_NO_SMP", 0))

def check_math_runtime(conf):
    header_name = "Python.h math.h"
    features = "c cprogram pyext"

    mlibs = ["", "m", "cpml"]
    mathlib = os.environ.get('MATHLIB')
    if mathlib:
        mlibs.insert(0, mathlib)

    mlib = None
    for lib in mlibs:
        try:
            st = conf.check_functions_at_once(["exp"], lib=lib, uselib_store="M")
            mlib = lib
            break
        except waflib.Errors.ConfigurationError:
            pass
    if mlib is None:
        raise waflib.Errors.ConfigurationError("No math lib found !")

    # XXX: this is ugly: mathlib has nothing to do in a public header file
    NUMPYCONFIG_SYM.append(('MATHLIB', ','.join(mlib)))

    conf.check_functions_at_once(MANDATORY_FUNCS, uselib="M")

    mfuncs = ('expl', 'expf', 'log1p', 'expm1', 'asinh', 'atanhf', 'atanhl',
              'rint', 'trunc')
    conf.check_functions_at_once(mfuncs, uselib="M")

    header_name = "Python.h math.h"
    features = "c pyext"
    for f in OPTIONAL_STDFUNCS_MAYBE:
        try:
            conf.check_declaration("HAVE_%s" % conflib.sanitize_string(f),
                                    header_name=header_name,
                                    features=features)
            OPTIONAL_STDFUNCS.remove(f)
        except waflib.Errors.ConfigurationError:
            pass

    conf.check_functions_at_once(OPTIONAL_STDFUNCS,
            features=features, mandatory=False, uselib="M")
    conf.check_functions_at_once(C99_FUNCS_SINGLE,
            features=features, mandatory=False, uselib="M")
    conf.check_functions_at_once(C99_FUNCS_EXTENDED,
            features=features, mandatory=False, uselib="M")

    for f in ["isnan", "isinf", "signbit", "isfinite"]:
        try:
            conf.check_declaration(f, header_name=header_name, features=features)
            NUMPYCONFIG_SYM.append(('DEFINE_NPY_HAVE_DECL_%s' % f.upper(),
                '#define NPY_HAVE_DECL_%s' % f.upper()))
        except waflib.Errors.ConfigurationError:
            NUMPYCONFIG_SYM.append(('DEFINE_NPY_HAVE_DECL_%s' % f.upper(), ''))

def check_complex(conf):
    if conf.check_header("complex.h"):
        NUMPYCONFIG_SYM.append(('DEFINE_NPY_USE_C99_COMPLEX',
                                '#define NPY_USE_C99_COMPLEX 1'))
        for t in C99_COMPLEX_TYPES:
            try:
                conf.check_type(t, header_name='complex.h')
                NUMPYCONFIG_SYM.append(('DEFINE_NPY_HAVE_%s' % conflib.sanitize_string(t),
                                        '#define NPY_HAVE_%s' % conflib.sanitize_string(t)))
            except waflib.Errors.ConfigurationError:
                NUMPYCONFIG_SYM.append(('DEFINE_NPY_HAVE_%s' % conflib.sanitize_string(t), ''))

        for prec in ["", "f", "l"]:
            flist = [f + prec for f in C99_COMPLEX_FUNCS]
            conf.check_functions_at_once(flist, uselib="M")
    else:
        NUMPYCONFIG_SYM.append(('DEFINE_NPY_USE_C99_COMPLEX', ''))
        for t in C99_COMPLEX_TYPES:
            NUMPYCONFIG_SYM.append(('DEFINE_NPY_HAVE_%s' % conflib.sanitize_string(t), ''))

def configure(conf):
    # TODO: remove this once we get proper configuration
    config_header_hack()

    try:
        conf.check_header("endian.h")
    except waflib.Errors.ConfigurationError:
        pass

    type_checks(conf)
    signal_smp_checks(conf)
    check_math_runtime(conf)
    conf.check_inline()
    check_complex(conf)

    conf.env["CONFIG_HEADER_TEMPLATE"] = """\
%(content)s
#ifndef _NPY_NPY_CONFIG_H_
#error config.h should never be included directly, include npy_config.h instead
#endif"""
    conf.write_config_header("config.h")   

    conf.env.INCLUDES = [".", "include", "include/numpy"]

def c_template_rule(task):
    s = task.inputs[0]
    cnt = s.read()
    writestr = process_c_str(cnt)
    t = task.outputs[0]
    t.write(writestr)

waflib.TaskGen.declare_chain(name="c_templates", rule=c_template_rule,
                             ext_in=".src", ext_out=[""], reentrant=False, before=["c"])

class numpy_api_generator(Task):
    vars = ["API_TUPLE"]
    color = "BLUE"
    before = ["c"]
    def run(self):
        targets = [o.path_from(self.generator.bld.srcnode) for o in self.outputs]
        generate_numpy_api.do_generate_api(targets, self.env.API_TUPLE)
        return 0

class ufunc_api_generator(Task):
    vars = ["API_TUPLE"]
    color = "BLUE"
    before = ["c"]
    def run(self):
        targets = [o.path_from(self.generator.bld.srcnode) for o in self.outputs]
        generate_ufunc_api.do_generate_api(targets, self.env.API_TUPLE)
        return 0

@waflib.TaskGen.feature("numpy_api_gen")
def process_multiarray_api_generator(self):
    tsk = self.create_task("numpy_api_generator")
    if hasattr(self, "api_tuple"):
        tsk.env.API_TUPLE = self.api_tuple
    else:
        if not "API_TUPLE" in tsk.env:
            tsk.env.API_TUPLE = ()
    header = "__%s.h" % self.pattern
    source = "__%s.c" % self.pattern
    txt = self.pattern + ".txt"
    files = [header, source, txt]
    tsk.set_outputs([self.path.find_or_declare(f) for f in files])
    return tsk

@waflib.TaskGen.feature("ufunc_api_gen")
def process_api_ufunc_generator(self):
    tsk = self.create_task("ufunc_api_generator")
    if hasattr(self, "api_tuple"):
        tsk.env.API_TUPLE = self.api_tuple
    else:
        if not "API_TUPLE" in tsk.env:
            tsk.env.API_TUPLE = ()
    header = "__%s.h" % self.pattern
    source = "__%s.c" % self.pattern
    txt = self.pattern + ".txt"
    files = [header, source, txt]
    tsk.set_outputs([self.path.find_or_declare(f) for f in files])
    return tsk

class umath_generator(Task):
    vars = ["API_TUPLE"]
    color = "BLUE"
    before = ["c"]
    def run(self):
        if len(self.outputs) > 1:
            raise ValueError("Only one target (the .c file) is expected in the umath generator task")
        code = generate_umath.make_code(generate_umath.defdict, generate_umath.__file__)
        self.outputs[0].write(code)
        return 0

@waflib.TaskGen.feature("umath_gen")
def process_umath_generator(self):
    tsk = self.create_task("umath_generator")
    source = "__%s.c" % self.pattern
    tsk.set_outputs(self.path.find_or_declare(source))
    return tsk

def build(bld):
    # C templates
    multiarray_templates = ["src/multiarray/scalartypes.c.src",
            "src/multiarray/arraytypes.c.src", 
            "src/multiarray/new_iterator.c.src", 
            "src/multiarray/lowlevel_strided_loops.c.src", 
            "src/multiarray/einsum.c.src"]
    bld(target="multiarray_templates", source=multiarray_templates)

    npymath_templates = ["src/npymath/npy_math.c.src",
            "src/npymath/npy_math_complex.c.src",
            "src/npymath/ieee754.c.src"]
    bld(target="npymath_templates", source=npymath_templates)

    ufunc_templates = ["src/umath/loops.c.src",
            "src/umath/umathmodule.c.src",
            "src/umath/funcs.inc.src"]
    bld(target="ufunc_templates", source=ufunc_templates)

    scalarmath_templates = ["src/scalarmathmodule.c.src"]
    bld(target="scalarmath_templates", source=scalarmath_templates)

    sort_templates = ["src/_sortmodule.c.src"]
    bld(target="sort_templates", source=sort_templates)

    # npymath 
    npymath_sources = [
            pjoin('src', 'npymath', 'npy_math.c'),
            pjoin('src', 'npymath', 'npy_math_complex.c'),
            pjoin('src', 'npymath', 'ieee754.c'),
            pjoin('src', 'npymath', 'halffloat.c')]
    # FIXME: hack to build static library that can be linked into a dlopen-able
    # library
    bld(features="c pyext cstlib",
        source=npymath_sources,
        includes=["src/private", "src/npymath"],
        uselib="cshlib",
        target="npymath")

    # multiarray
    bld(name="multiarray_api",
        features="numpy_api_gen",
        api_tuple=multiarray_api,
        pattern="multiarray_api")

    # sort
    includes = [".", "src/private"]
    bld(features="c cshlib pyext",
        target="_sort",
        source="src/_sortmodule.c",
        includes=includes,
        uselib_local="npymath")

    includes = ["src/multiarray", "src/private"]
    bld(features="c cshlib pyext",
        includes=includes,
        target="multiarray",
        source="src/multiarray/multiarraymodule_onefile.c",
        uselib_local="npymath")

    # ufunc
    bld(features="ufunc_api_gen",
        api_tuple=ufunc_api,
        pattern="ufunc_api",
        name="ufunc_api")

    bld(features="umath_gen",
        pattern="umath_generated",
        name="umath_gen")

    includes = ["src/umath", "src/private"]
    bld(features="c cshlib pyext",
        includes=includes,
        target="umath",
        source="src/umath/umathmodule_onefile.c",
        uselib_local="npymath")

    # scalar math
    bld(features="c cshlib pyext",
        #includes=includes,
        target="scalarmath",
        source="src/scalarmathmodule.c",
        uselib_local="npymath")
